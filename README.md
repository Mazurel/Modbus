<h1>Modbus library for modern c++</h1>

Modbus library for high level frame manipulation with modern C++17.

Contains simple linux TCP and RTU implementation.

# Contents

- [Why](#why)
- [Important Concept](#important-concept)
- [Possibilities](#possibilities)
- [Dependencies](#dependencies)
- [Status](#status)
- [Installation](#how-to-install-it-)
- [Api](#api)

# Why

When I was working on my last project and tried to find a good c++ Modbus library (other than Qt) I was unable to find it.
That is why I have decided to share my own implementation of it.

# Important Concept

This library is **mainly** for providing Modbus logic, it doesnt aim to have best communiaction implementation.
It gives user ability to create Modbus frames in high level api and convert them to raw bytes or show them as string.
That is why _Modbus Core_ is OS independent and can be easily used with other communication frameworks.

It does have communiaction module which is **enabled** by default, and works pretty well on linux.

# Possibilities

Quick example of what Modbus Core can do:

Code:

```c++
#include <modbusRequest.hpp>

// Create simple request
MB::ModbusRequest request(1, MB::Utils::ReadDiscreteOutputCoils, 100, 10);

std::cout << "Stringed Request: " << request.to_string() << std::endl;

std::cout << "Raw request:" << std::endl;

// Get raw represenatation for request
std::vector<uint8_t> rawed = request.to_raw();

// Method for showing byte
auto showByte = [](const uint8_t& byte)
{
    std::cout << " 0x" << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
};

// Show all bytes
std::for_each(rawed.begin(), rawed.end(), showByte);
std::cout << std::endl;

// Create CRC and pointer to its bytes
uint16_t CRC = MB::Utils::calculate_crc(rawed);
auto CRCptr = reinterpret_cast<uint8_t *>(&CRC);

// Show byted CRC for request
std::cout << "CRC for the above code: ";
std::for_each(CRCptr, CRCptr + 2, showByte);
std::cout << std::endl;


auto request1 = MB::ModbusRequest::from_raw(rawed);
std::cout << "Stringed Request 1 after rawed: " << request1.to_string() << std::endl;

// Add CRC to the end of raw request so that it can be loaded with CRC check
rawed.insert(rawed.end() , CRCptr, CRCptr + 2);
auto request2 = MB::ModbusRequest::from_raw_crc(rawed); // Throws on invalid CRC
std::cout << "Stringed Request 2 after rawed: " << request2.to_string() << std::endl;
```

Output:

```bash
Stringed Request: Read from output coils, from slave 1, starting from address 100, on 10 registers
Raw request:
 0x01 0x01 0x00 0x64 0x00 0x0a
CRC for the above code:  0xfd 0xd2
Stringed Request 1 after rawed: Read from output coils, from slave 1, starting from address 100, on 10 registers
Stringed Request 2 after rawed: Read from output coils, from slave 1, starting from address 100, on 10 registers
```

# Dependencies

- libnet - only for tcp communication (not needed if communication is disabled)

# STATUS

Currently Modbus Core is fully functional and (I belive) it doesn't have any bugs.

API for it is in progress.

Modbus Communication is working _currently_ only for linux, it works well on TCP and Serial (tested on raspberry pi).

# How to learn Modbus ?

Just use [Simply modbus](http://www.simplymodbus.ca/FAQ.htm).

# How to install it ?

### Using CMAKE and git

First go to directory that will contain this library.

```bash
git clone https://github.com/Mazurel/Modbus
git submodule update --init --recursive # Fetch submodules (google tests)
```

Then add to your CMakeLists.txt

```cmake
add_subdirectory(Modbus)
target_link_libraries(<your exec/lib> Modbus)
```

You should be able to use library.

**NOTE**
If you are on other os then gnu/linux you should disable communication part of modbus via cmake variable MODBUS_COMMUNICATION.

# API

[link](https://raw.githack.com/Mazurel/Modbus/master/docs/html/index.html)

## It is the best to use docs generated by doxygen

You can read it in [docs/html](https://raw.githack.com/Mazurel/Modbus/master/docs/html/index.html) or generate it yourself via:

```bash
doxygen Doxyfile
```

## The below API is not finished (propably wont be), it is preffered to use doxygen for code documentation.

- [Enums](#enums)
- [Methods](#methods)
- [Classes](#classes)

## Enums

Below each enum there are all values of enum.

- `MB::Utils::MBErrorCode` - Enum that contains all the standard Modbus error Codes as well as Modbus library specific errors.

  ```c++
  // Documentation modbus errors:
  IllegalFunction = 0x01
  IllegalDataAddress = 0x02
  IllegalDataValue = 0x03
  SlaveDeviceFailure = 0x04
  Acknowledge = 0x05
  SlaveDeviceBusy = 0x06
  NegativeAcknowledge = 0x07
  MemoryParityError = 0x08
  GatewayPathUnavailable = 0x10
  GatewayTargetDeviceFailedToRespond = 0x11

  // Custom modbus errors:
  ErrorCodeCRCError = 0b0111111
  InvalidCRC = 0b01111110
  InvalidByteOrder = 0b01111101
  InvalidMessageID = 0b01111100
  ProtocolError = 0b01111011
  ConnectionClosed = 0b01111010
  Timeout = 0b01111001
  ```

- `MB::Utils::MBFunctionCode` - Enum that contains all Modbus function codes.

  ```c++
  // Reading functions
  ReadDiscreteOutputCoils = 0x01
  ReadDiscreteInputContacts = 0x02
  ReadAnalogOutputHoldingRegisters = 0x03
  ReadAnalogInputRegisters = 0x04

  // Single write functions
  WriteSingleDiscreteOutputCoil = 0x05
  WriteSingleAnalogOutputRegister = 0x06

  // Multiple write functions
  WriteMultipleDiscreteOutputCoils = 0x0F
  WriteMultipleAnalogOutputHoldingRegisters = 0x10

  // Custom
  Undefined = 0x00
  ```

- `MB::Utils::MBFunctionType` - Enum that contains function types.
  ```c++
  Read
  WriteSingle
  WriteMultiple
  ```
- `MB::Utils::MBFunctionRegisters` - Enum that contains all register types.
  ```c++
  OutputCoils
  InputContacts
  HoldingRegisters
  InputRegisters
  ```

## Methods

- `bool MB::Utils::isStandardErrorCode(MBErrorCode code)` -
  Returns true if specified code is a Modbus standard error code.
- `std::string MB::Utils::modbus_error_code_to_str(MBErrorCode code)` -
  Returns stringed name of a specified Modbus error code.
- `MBFunctionType MB::Utils::function_type(const MBFunctionCode code)` -
  Get functions type based on function code.
- `MBFunctionRegisters MB::Utils::function_register(const MBFunctionCode code)` -
  Get functions register based on function code.
- `uint16_t MB::Utils::big_endian_conv(const uint8_t *buf)` -
  Creates uint16_t number from uint8_t buffer of two bytes (used when reading modbus frames).
- `uint16_t MB::Utils::calculate_crc(const uint8_t *buff, size_t len)`

  `uint16_t MB::Utils::calculate_crc(const std::vector<uint8_t>& buffer)` -
  Pretty self explanatory.

## Classes

> For each getter and setter field there is:
>
> \<name\>() const - that gets the value
>
> set\<Name\>(value) - that sets value

#### ModbusException

Its prupose is to represent Modbus exception, either frame or c++ exception

- Constructor:
  - `ModbusException(const std::vector<uint8_t>& inputData, bool CRC = false);` -
    Creates ModbusException from raw bytes, with CRC check based on parameter.
  - `ModbusException(Utils::MBErrorCode errorCode,
uint8_t slaveId = 0xFF,
Utils::MBFunctionCode function_code = Utils::Undefined)
                                     noexcept :
                                     _slave_id(slaveId),
                                     _valid_slave(true),
                                     _error_code(errorCode),
                                     _function_code(function_code)
                                     {}` -
    Creates Modbus exception based on it's properties.
- Methods:
  - `static ModbusException::exist(const std::vector<uint8_t>& inputData)` -
    Checks if there is exception in modbus frame.
  - `std::string to_string()` -
    Returns string representation of exception.
  - `std::vector<uint8_t> to_raw()` -
    Retruns raw frame represenation of a excaption.
- Getters and setters:
  - function_code
  - slave_id

#### ModbusRequest

Its purpose is to represent modbus request frame.

- Constructors:
  - `static ModbusRequest(std::vector<uint8_t> inputData, bool CRC = false)` -
    Creates Modbus request based on raw bytes and CRC boolean. If CRC is ON and the check fails constructor throws exception.
  - `static ModbusRequest::from_raw(const std::vector<uint8_t>& inputData)` -
    Creates ModbusRequest from raw bytes.
  - `static ModbusRequest::from_raw_crc(const std::vector<uint8_t>& inputData)` -
    Creates ModbusRequest from raw bytes and checks CRC.
    When CRC is invalid throws InvalidCRC exception.
  - `ModbusRequest(uint8_t slaveId = 0,
Utils::MBFunctionCode function_code = static_cast<Utils::MBFunctionCode>(0),
uint16_t address = 0,
uint16_t registersNumber = 0,
std::vector<ModbusCell> values = {})` -
    Self explanatory.
- Methods:
  - `std::string ModbusRequest::to_string()` -
    Returns string representation of a request.
  - `std::vector<uint8_t> ModbusRequest::to_raw()` -
    Converts ModbusRequest to raw bytes.
  - `MB::Utils::MBFunctionType function_type() const` -
    Gets function type for current function code.
  - `MB::Utils::MBFunctionRegisters function_registers() const` -
    Gets function register for current function code.
- Getters and setters:
  - slave_id
  - function_code
  - register_address
  - number_of_registers
  - register_values

#### ModbusResponse

Its purpose is to represent response frame.

- Constructors:
  - `static ModbusResponse(std::vector<uint8_t> inputData, bool CRC = false)` -
    Creates Modbus response based on raw bytes and CRC boolean. If CRC is ON and the check fails constructor throws exception.
  - `static ModbusResponse::from_raw(const std::vector<uint8_t>&)` -
    Creates ModbusResponse from raw bytes
  - `static ModbusResponse::from_raw_crc(const std::vector<uint8_t>&)` -
    Creates ModbusResponse from raw bytes and checks CRC.
    When CRC is invalid throws InvalidCRC exception.
  - `ModbusResponse(uint8_t slaveId = 0,
Utils::MBFunctionCode function_code = 0x00,
uint16_t address = 0,
uint16_t registersNumber = 0,
std::vector<ModbusCell> values = {})` -
    Self explanatory constructor.
- Methods:
  - `std::string to_string()` -
    Returns ModbusResponse string representation.
  - `std::vector<uint8_t> to_raw()` -
    Converts ModbusResponse to vector of raw bytes.
  - `void from(const ModbusRequest&)` -
    Fills ModbusResponse with the request.
    Needed if you want ModbusResponse to have all the data.
    This method is needed when you create object from raw.
  - `MB::Utils::MBFunctionType function_type() const` -
    Gets function type for current function code.
  - `MB::Utils::MBFunctionRegisters function_registers() const` -
    Gets function register for current function code.
- Getters and setters:
  - slave_id
  - function_code
  - register_address
  - number_of_registers
  - register_values
